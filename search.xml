<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux内核链表</title>
      <link href="/2022/07/18/linux-kernel-linklist/"/>
      <url>/2022/07/18/linux-kernel-linklist/</url>
      
        <content type="html"><![CDATA[<h2 id="1、Linux内核链表"><a href="#1、Linux内核链表" class="headerlink" title="1、Linux内核链表"></a>1、Linux内核链表</h2><h5 id="1-链表数据区域的局限性"><a href="#1-链表数据区域的局限性" class="headerlink" title="1. 链表数据区域的局限性"></a>1. 链表数据区域的局限性</h5><p>【1】前面讲到的节点中的数据区都十分简单是一个int类型的数，实际上编程中连接中的节点不可能这么简单，一般都是结构体。</p><h5 id="2-一般解决思路：对数据区封装为一个结构体"><a href="#2-一般解决思路：对数据区封装为一个结构体" class="headerlink" title="2. 一般解决思路：对数据区封装为一个结构体"></a>2. 一般解决思路：对数据区封装为一个结构体</h5><p>【1】内核链表将对链表标准的操作进行了一次封装（创建、插入、删除、遍历），用户只需要实现特定的数据部分即可。这样避开了编程难点，使开发更容易。（例子：造汽车中的发动机和外壳）</p><h5 id="3-内核链表的设计思路"><a href="#3-内核链表的设计思路" class="headerlink" title="3. 内核链表的设计思路"></a>3. 内核链表的设计思路</h5><p>【1】内核链表中自己实现了一个纯链表（没有数据区，只有前后指针）的封装。已经各种操作，纯链表座位核心，给用户调用。</p><h5 id="4-list-h文件"><a href="#4-list-h文件" class="headerlink" title="4. list.h文件"></a>4. list.h文件</h5><p>内核中纯链表的实现在include / linux / list.h文件中<br>文件包含纯链表以及它的各种操作。</p><h2 id="2、内核链表的基本算法和使用"><a href="#2、内核链表的基本算法和使用" class="headerlink" title="2、内核链表的基本算法和使用"></a>2、内核链表的基本算法和使用</h2><h5 id="1-list-h中，函数名前面添加有-的函数是操作系统来使用的函数，用户尽量不要使用"><a href="#1-list-h中，函数名前面添加有-的函数是操作系统来使用的函数，用户尽量不要使用" class="headerlink" title="1. list.h中，函数名前面添加有__的函数是操作系统来使用的函数，用户尽量不要使用"></a>1. list.h中，函数名前面添加有__的函数是操作系统来使用的函数，用户尽量不要使用</h5><h5 id="2-内核链表的使用：将内核链表作为整个数据结构的结构体的一个成员内嵌进去"><a href="#2-内核链表的使用：将内核链表作为整个数据结构的结构体的一个成员内嵌进去" class="headerlink" title="2. 内核链表的使用：将内核链表作为整个数据结构的结构体的一个成员内嵌进去"></a>2. 内核链表的使用：将内核链表作为整个数据结构的结构体的一个成员内嵌进去</h5><p><img src="/./blog/linux1.png" alt="内核链表"></p><p>上图为driver的两种写法。</p><p><img src="/./blog/linux2.png" alt="内核链表注释"><br><img src="/./blog/linux3.png" alt="内核链表注释"></p><h2 id="3、状态机"><a href="#3、状态机" class="headerlink" title="3、状态机"></a>3、状态机</h2><h5 id="1-有限状态机"><a href="#1-有限状态机" class="headerlink" title="1. 有限状态机"></a>1. 有限状态机</h5><p>【1】常说的状态机为FSM（有限个状态），这个机器能同时从外部接收信号和信息输入，及其在接收到外部输入的信号后会综合考虑当前自己的状态和用户输入的信息 ，然后做出动作<br>【2】状态机的关键：当前状态、外部输入、下一个状态</p><h5 id="2-两种状态机：Moore型-和-Mealy型"><a href="#2-两种状态机：Moore型-和-Mealy型" class="headerlink" title="2. 两种状态机：Moore型 和 Mealy型"></a>2. 两种状态机：Moore型 和 Mealy型</h5><p>【1】Moore型状态机的特点：输出只和当前状态有关。简单，考虑状态机的下一个状态只需考虑当前状态就行。<br>【2】Mealy型状态机的特点：输出和当前状态和输入信号都有关系。状态机在接收到消息之后，需要考虑两个因素，最后做出决定。（水的三种状态）</p><h5 id="3-状态机的主要用途：电路设计、FPGA程序设计、软件设计（框架、GUI、消息机制）"><a href="#3-状态机的主要用途：电路设计、FPGA程序设计、软件设计（框架、GUI、消息机制）" class="headerlink" title="3.状态机的主要用途：电路设计、FPGA程序设计、软件设计（框架、GUI、消息机制）"></a>3.状态机的主要用途：电路设计、FPGA程序设计、软件设计（框架、GUI、消息机制）</h5><h5 id="4-状态机解决什么问题：平时的程序都是顺序执行的，如果输入的信息有误，程序可能会识别不了。但是现实中程序需要去判断输入，做出符合逻辑的判断。"><a href="#4-状态机解决什么问题：平时的程序都是顺序执行的，如果输入的信息有误，程序可能会识别不了。但是现实中程序需要去判断输入，做出符合逻辑的判断。" class="headerlink" title="4.状态机解决什么问题：平时的程序都是顺序执行的，如果输入的信息有误，程序可能会识别不了。但是现实中程序需要去判断输入，做出符合逻辑的判断。"></a>4.状态机解决什么问题：平时的程序都是顺序执行的，如果输入的信息有误，程序可能会识别不了。但是现实中程序需要去判断输入，做出符合逻辑的判断。</h5><h5 id="5-C语言实现状态机"><a href="#5-C语言实现状态机" class="headerlink" title="5.C语言实现状态机"></a>5.C语言实现状态机</h5><p><img src="/./blog/linux4.png" alt="要求"><br><img src="/./blog/linux5.png" alt="定义"><br><img src="/./blog/linux7-1.png" alt="声明"></p><p>使用switch判断current_state</p><p><img src="/./blog/linux6.png" alt="Switch"></p><h2 id="4、多线程"><a href="#4、多线程" class="headerlink" title="4、多线程"></a>4、多线程</h2><h5 id="1-操作系统下的并行执行机制"><a href="#1-操作系统下的并行执行机制" class="headerlink" title="1. 操作系统下的并行执行机制"></a>1. 操作系统下的并行执行机制</h5><h5 id="2-进程和线程的区别和联系"><a href="#2-进程和线程的区别和联系" class="headerlink" title="2. 进程和线程的区别和联系"></a>2. 进程和线程的区别和联系</h5><p><img src="/./blog/linux7.png" alt="进程与线程"></p><h5 id="3-多线程的优势"><a href="#3-多线程的优势" class="headerlink" title="3. 多线程的优势"></a>3. 多线程的优势</h5><p>多核心CPU给多线程程序提供了完美的运行环境。</p><h5 id="4-线程同步和锁"><a href="#4-线程同步和锁" class="headerlink" title="4. 线程同步和锁"></a>4. 线程同步和锁</h5>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel </tag>
            
            <tag> LinkList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署网站到云服务器</title>
      <link href="/2022/06/30/web-deploy/"/>
      <url>/2022/06/30/web-deploy/</url>
      
        <content type="html"><![CDATA[<p>由于GitHub服务器在国外，访问速度慢，我们可以将网站部署到国内的云服务器上。</p><p>这篇文章使用宝塔面板将hexo部署到腾讯云服务器上。</p><h2 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a>1. 前提</h2><p>已经搭建好 hexo 的相关环境，并将 hexo 部署到了 GitHub 上<br>已经购买好云服务器<br>已经购买并备案好域名 （可选项，没有也可以用 ip 地址访问 hexo）</p><h2 id="2-宝塔面板"><a href="#2-宝塔面板" class="headerlink" title="2. 宝塔面板"></a>2. 宝塔面板</h2><p>宝塔面板可以可视化地操作远端服务器（这样就不用自己手动装 nginx 了）</p><p>进入宝塔面板的下载页面 宝塔面板下载 ，找到 Linux 面板，点击安装脚本 (如果买的服务器是 Windows 的就点 Windows 的)</p><p>根据自己服务器的类型，复制对应的代码</p><p>进入腾讯云的控制台，选择自己的云服务器，点击登录，进入终端。</p><p>粘贴刚才复制的代码，回车，一路确认。</p><p>在浏览器中访问外网面板地址，使用宝塔提供的用户名和密码登录。</p><p>进入面板后，点击一键安装 LNMP。就能直接将 Nginx，MySQL 等网站所需内容一键安装好。</p><h2 id="3-安装并配置-Git-仓库"><a href="#3-安装并配置-Git-仓库" class="headerlink" title="3.安装并配置 Git 仓库"></a>3.安装并配置 Git 仓库</h2><p>在远程服务器上配置好 Git 仓库后，才能将本地的 hexo push 到远端。</p><p>安装 git （远程服务器上）</p><pre><code>yum install git</code></pre><p>配置 git 用户</p><pre><code>adduser git</code></pre><p>赋予用户权限</p><pre><code>chmod 740 /etc/sudoersvi /etc/sudoers</code></pre><p>输入 i 进入 insert 模式 ，找到 root ALL=(ALL) ALL ，在其下方加入一行 git ALL=(ALL) ALL</p><pre><code>root    ALL=(ALL)       ALLgit     ALL=(ALL)       ALL</code></pre><p>按下 ESC ，输入 wq ，保存 vim 文件。</p><p>修改 sudoers 文件权限</p><pre><code>chmod 400 /etc/sudoers </code></pre><p>设置 git 用户的密码</p><pre><code>sudo passwd git</code></pre><p>给 git 用户添加 ssh 秘钥 （找到本地的 ssh 公钥，部署 hexo 到 GitHub 时有生成，以 .pub 结尾）</p><pre><code>su - gitmkdir -p ~/.sshtouch ~/.ssh/authorized_keyschmod 600 ~/.ssh/authorzied_keyschmod 700 ~/.sshvim ~/.ssh/authorized_keys   </code></pre><p>在本地打开一个终端，以 ssh 的方式登录云服务器</p><pre><code>ssh -v git@你的 ip 地址// 输入密码 即可成功登录云服务器</code></pre><p>创建一个 git 仓库，新建一个 post-receive 文件，用来存储本地的提交。</p><pre><code>su rootcd /home/gitgit init --bare blog.git  #在/home/git下创建新仓库blog.gitchown git:git -R blog.git #给予git用户权限</code></pre><p>在 blog.git/hooks 文件夹下创建一个 post-receive 钩子，把提交到 git 仓库的文件同步到 home/hexo文件夹中</p><pre><code>cd blog.git/hooksvim post-receive</code></pre><p>在 post-receive 文件中输入以下代码</p><pre><code> #!/bin/bash   git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</code></pre><p>授予 post-receive 文件可执行权限</p><pre><code>chmod +x /home/git/blog.git/hooks/post-receive</code></pre><p>至此服务端已经配置完成。</p><h2 id="4-部署-hexo"><a href="#4-部署-hexo" class="headerlink" title="4. 部署 hexo"></a>4. 部署 hexo</h2><p>打开 hexo 的配置文件_config.yml修改Deployment位置的配置</p><pre><code>deploy:    type: git    repo: root@你的ip地址:/home/git/blog.git    branch: master</code></pre><p>保存配置文件，打开终端进入 hexo 博客所在文件夹</p><pre><code>cd blog //进入自己博客所在文件夹hexo cleanhexo g //编译hexo d //部署</code></pre><p>此时已经可以通过 ip:80 来访问了</p><h2 id="5-通过域名访问-hexo"><a href="#5-通过域名访问-hexo" class="headerlink" title="5. 通过域名访问 hexo"></a>5. 通过域名访问 hexo</h2><p>在云服务器下创建一个二级域名<br>进入域名服务商的DNS解析页面，点击解析<br>点击添加记录，并按图中操作执行。<br>打开宝塔面板，依次点击网站，添加站点<br>输入刚才创建的二级域名，设置根目录，创建网站</p><h2 id="6-配置SSL"><a href="#6-配置SSL" class="headerlink" title="6. 配置SSL"></a>6. 配置SSL</h2><p>现在我们的网站还是 http 开头，会被标识为不安全，所以需要配置 SSL ,将 http 转化为 https.</p><p>如图所示，依次点击</p><p>选择域名，点击申请。申请成功后点击强制 https</p><p>http 运行在 80 端口，而 https 运行在 443 端口。强制 https 后会打开 443端口，但这个并不会生效。</p><p>所以我们需要先关闭 443 端口，再重新打开 443 端口。</p><p>在安全页面，删除 443 端口，再放行 443 端口</p><p>现在就可以用 你的域名来访问博客了</p><h2 id="7-若无法通过域名访问"><a href="#7-若无法通过域名访问" class="headerlink" title="7.若无法通过域名访问"></a>7.若无法通过域名访问</h2><pre><code>sudo vim /etc/ssh/sshd_config增加修改PasswordAuthentication yessudo systemctl restart sshd</code></pre><p>root用户远程登录，要确保</p><pre><code>/etc/ssh/sshd_configPermitRootLogin yes</code></pre><p>即可成功访问</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practice </tag>
            
            <tag> Web_Deploy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程</title>
      <link href="/2021/05/13/linux-netprogram/"/>
      <url>/2021/05/13/linux-netprogram/</url>
      
        <content type="html"><![CDATA[<h1 id="linux网络编程框架"><a href="#linux网络编程框架" class="headerlink" title="linux网络编程框架"></a>linux网络编程框架</h1><h2 id="（1）网络是分层的"><a href="#（1）网络是分层的" class="headerlink" title="（1）网络是分层的"></a>（1）网络是分层的</h2><p>【1】OSI七层模型<br>【2】网络为什么分层、以及具体表现</p><p><img src="/./blog/clipboard.png" alt="网络分层"></p><h4 id="【注】应用层软件在通信时，数据有定向功能：例如QQ发送的消息，不会被浏览器收到。"><a href="#【注】应用层软件在通信时，数据有定向功能：例如QQ发送的消息，不会被浏览器收到。" class="headerlink" title="【注】应用层软件在通信时，数据有定向功能：例如QQ发送的消息，不会被浏览器收到。"></a>【注】应用层软件在通信时，数据有定向功能：例如QQ发送的消息，不会被浏览器收到。</h4><h4 id="【注】网络编程学习的重点：应用层（API-APP），不用关心其他层次，功能一样可以实现。"><a href="#【注】网络编程学习的重点：应用层（API-APP），不用关心其他层次，功能一样可以实现。" class="headerlink" title="【注】网络编程学习的重点：应用层（API+APP），不用关心其他层次，功能一样可以实现。"></a>【注】网络编程学习的重点：应用层（API+APP），不用关心其他层次，功能一样可以实现。</h4><h2 id="（2）TCP-x2F-IP协议"><a href="#（2）TCP-x2F-IP协议" class="headerlink" title="（2）TCP/IP协议"></a>（2）TCP/IP协议</h2><p>【1】TCP/IP是使用最多的网络协议实现<br>【2】TCP/IP分为四层，对应OSI的七层<br>【3】编程时，最关注应用层、了解传输层、不管网络层和网络接入层</p><h2 id="（3）BS和CS"><a href="#（3）BS和CS" class="headerlink" title="（3）BS和CS"></a>（3）BS和CS</h2><p>【1】CS架构（client server，客户端服务器架构）<br>【2】BS架构（broswer server，浏览器服务器架构）</p><h1 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h1><p><img src="/./blog/clipboard1.png" alt="三次握手示意图"></p><h2 id="（1）关于TCP理解的重点"><a href="#（1）关于TCP理解的重点" class="headerlink" title="（1）关于TCP理解的重点"></a>（1）关于TCP理解的重点</h2><p>【1】TCP协议工作在传输层，对上服务socket接口，对下调用IP函数。<br>【2】TCP协议面向连接，通信前必须先3次握手建立连接关系之后才能开始通信。【注】QQ消息非面向连接。<br>【3】TCP协议提供可靠传输，不怕丢包、乱序等。</p><h2 id="（2）TCP如何保证可靠传输"><a href="#（2）TCP如何保证可靠传输" class="headerlink" title="（2）TCP如何保证可靠传输"></a>（2）TCP如何保证可靠传输</h2><h3 id="TCP数据包内部："><a href="#TCP数据包内部：" class="headerlink" title="TCP数据包内部："></a>TCP数据包内部：</h3><p>【1】TCP在传输有效信息前要求通信双方必须先握手，建立连接之后才能通信<br>【2】TCP的接收方收到数据包后会ack给发送方，若发送方未收到ack则会重传<br>【3】TCP的有效数据内容会附带校验，防止内容在传递过程中损坏<br>【4】TCP会根据网络带宽开自动调节适配速率（滑动串口技术）</p><h3 id="TCP数据包之间"><a href="#TCP数据包之间" class="headerlink" title="TCP数据包之间"></a>TCP数据包之间</h3><p>【5】发送方会给各分割报文编号，接收方会校验编号，顺序出错即会重传</p><h2 id="（3）TCP的三次握手"><a href="#（3）TCP的三次握手" class="headerlink" title="（3）TCP的三次握手"></a>（3）TCP的三次握手</h2><p>【1】建立连接需要三次握手<br>【2】建立连接的条件：服务器listen时，客户端主动发起connect</p><h2 id="（4）TCP的四次握手"><a href="#（4）TCP的四次握手" class="headerlink" title="（4）TCP的四次握手"></a>（4）TCP的四次握手</h2><p>【1】关闭连接需要四次握手<br>【2】服务器或者客户端都可以主动发起关闭</p><h4 id="【注】这些握手协议已经封装在TCP协议内部，socket编程接口平时不用管"><a href="#【注】这些握手协议已经封装在TCP协议内部，socket编程接口平时不用管" class="headerlink" title="【注】这些握手协议已经封装在TCP协议内部，socket编程接口平时不用管"></a>【注】这些握手协议已经封装在TCP协议内部，socket编程接口平时不用管</h4><h2 id="（5）基于TCP通信的服务模式"><a href="#（5）基于TCP通信的服务模式" class="headerlink" title="（5）基于TCP通信的服务模式"></a>（5）基于TCP通信的服务模式</h2><p>【1】服务器具有公网IP地址（或者使用动态IP地址映射技术）<br>【2】服务器端socket、bind、listen后处于监听状态<br>【3】客户端socket后，直接connect去发起连接<br>【4】服务器收到并同意客户端接入后，会建立TCP连接，然后双方开始收发数据，手法时是双向的，切双方均可发起<br>【5】双发均可发起关闭连接</p><h2 id="（6）常见的使用了TCP协议的网络应用"><a href="#（6）常见的使用了TCP协议的网络应用" class="headerlink" title="（6）常见的使用了TCP协议的网络应用"></a>（6）常见的使用了TCP协议的网络应用</h2><p>【1】http、ftp<br>【2】QQ服务器<br>【3】mail服务器</p><h1 id="socket编程接口"><a href="#socket编程接口" class="headerlink" title="socket编程接口"></a>socket编程接口</h1><h2 id="（1）建立连接"><a href="#（1）建立连接" class="headerlink" title="（1）建立连接"></a>（1）建立连接</h2><h2 id="（2）发送和接收"><a href="#（2）发送和接收" class="headerlink" title="（2）发送和接收"></a>（2）发送和接收</h2><h2 id="（3）辅助性函数"><a href="#（3）辅助性函数" class="headerlink" title="（3）辅助性函数"></a>（3）辅助性函数</h2><h2 id="（4）表示IP地址相关的数据结构"><a href="#（4）表示IP地址相关的数据结构" class="headerlink" title="（4）表示IP地址相关的数据结构"></a>（4）表示IP地址相关的数据结构</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Network programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes From Life</title>
      <link href="/2021/02/09/notes-from-movie/"/>
      <url>/2021/02/09/notes-from-movie/</url>
      
        <content type="html"><![CDATA[<pre><code>    记录电影和阅读中的台词或心得</code></pre><h2 id="《Wonder-Woman-1984》"><a href="#《Wonder-Woman-1984》" class="headerlink" title="《Wonder Woman 1984》"></a>《Wonder Woman 1984》</h2><p> “I’m so glad I wished you’d come. I knew it would work.”</p><p> “No. That is not why I’m back. I’ve been lying to you. I’m not a great guy. In fact I’m a pretty messed up,loser guy.”</p><p> “And I made terrible mistake. But you”</p><p> “You don’t ever have to make a wish for me to love you. I’m here because I love you.”</p><p> “I just wish and I pray that,one day I’ll be albe to make you proud enough that you’ll able to forgive me. And love me.”</p><p> “Because I’m nothing to be proud of”</p><p> “I don’t need you to make me proud. I already love you.”</p><h2 id="《一天》"><a href="#《一天》" class="headerlink" title="《一天》"></a>《一天》</h2><p>对待生命，我们不妨大胆一些，因为我们终归要失去它。</p><p>一个爱的刻骨铭心难以释怀，一个有那么点喜欢但还不够爱，爱情里比绝望更痛苦的，是永远有那么一点希望</p><h2 id="Reading-Note"><a href="#Reading-Note" class="headerlink" title="Reading Note"></a>Reading Note</h2><p>作家冯唐曾经说过，<br>中年危机的根源在于“确定感”<br>因为人一旦到了中年，就已经知道自己多少斤两，<br>哪些事你能干，哪些事你一辈子干不了。<br>中年的残酷就在于此，<br>上有老，下有小，每天生活两点一线毫无新意。<br>稳定的人一眼就能看到退休<br>不稳定的人被物质，家人，精神，友情，健康压得喘不过气<br>就像小丑抛在空中的几个球，<br>你必须足够优秀，才能争取，不让一个掉在地上。   </p><h2 id="《眩：北斋之女》"><a href="#《眩：北斋之女》" class="headerlink" title="《眩：北斋之女》"></a>《眩：北斋之女》</h2><p>要想磨练画技，先学别人<br>模仿再模仿，把画技刻进身体里<br>没有画技，就想追求风格独树一帜<br>这样好高骛远的人<br>最终都会走进死胡同</p><p>不仅仅是绘画，任何事物，任何行业都是通用的</p><p>你想拥有属于自己的东西<br>就必须先学习大量别人的东西<br>没有厚积，谈何薄发？<br>没有沉淀，何来升华？</p><h2 id="《Suicide-Squad》"><a href="#《Suicide-Squad》" class="headerlink" title="《Suicide Squad》"></a>《Suicide Squad》</h2><p>这种男人强大到无需被人疼被人爱，但只懂你，只宠你一个人<br>把你捧在手心，免你惊，免你苦，免你无枝可依<br>哪怕全世界的灿烂，都不及他一个人的温暖<br>他就像是深夜的一碗汤面，夏天的一瓶清水，从来都是那么恰到好处<br>在你需要的时候，永远在你身边，守护着你</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Movie </tag>
            
            <tag> Actor&#39;s Lines </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT :华为LiteOS开发环境搭建</title>
      <link href="/2021/02/01/iot-ch2-liteos-develop-env/"/>
      <url>/2021/02/01/iot-ch2-liteos-develop-env/</url>
      
        <content type="html"><![CDATA[<h1 id="IOT-华为LiteOS开发环境搭建"><a href="#IOT-华为LiteOS开发环境搭建" class="headerlink" title="IOT :华为LiteOS开发环境搭建"></a>IOT :华为LiteOS开发环境搭建</h1><h2 id="一、什么是操作系统"><a href="#一、什么是操作系统" class="headerlink" title="一、什么是操作系统"></a>一、什么是操作系统</h2><h4 id="1-1-公司发展案例"><a href="#1-1-公司发展案例" class="headerlink" title="1.1 公司发展案例"></a>1.1 公司发展案例</h4><p> （1）初创期一个人，主要是干活，直接产出价值。不需要管理。<br> （2）发展期10个人，一起干活，当面沟通，稍有组织即可，不需要专业化管理。<br> （3）规模期几百几千几万人，部分人纯干活，部分人干活加管理，部分人纯管理。<br> （4）总结：任何组织和系统的演变发展方向都是组织整体效率最优化配置。<br> （5）干活、沟通、管理必须模块化划分，然后再有效结合，被证明是最有效的方式。</p><h4 id="1-2-为什么用操作系统"><a href="#1-2-为什么用操作系统" class="headerlink" title="1.2 为什么用操作系统"></a>1.2 为什么用操作系统</h4><h5 id="1-2-1-从裸机到操作系统是必然发展路线"><a href="#1-2-1-从裸机到操作系统是必然发展路线" class="headerlink" title="1.2.1 从裸机到操作系统是必然发展路线"></a>1.2.1 从裸机到操作系统是必然发展路线</h5><p> （1）发展阶段1：裸机并且全部代码自写<br> （2）发展阶段2：裸机但调用库函数<br> （3）发展阶段3：裸机加状态机实现简单的多任务<br> （4）发展阶段4：上简单操作系统：RTOS（ucos、LiteoS）<br> （5）发展阶段5：上复杂操作系统：Linux、Windows、Android</p><h5 id="1-2-2-使用操作系统的优势"><a href="#1-2-2-使用操作系统的优势" class="headerlink" title="1.2.2 使用操作系统的优势"></a>1.2.2 使用操作系统的优势</h5><p> （1）轻松实现多任务<br> （2）轻松借用很多第三方组件功能<br> （3）更好实现可移植性<br> （4）减少项目开发复杂度（类比汽车自动挡和手动挡）<br> （5）代价就是操作系统自身的开销（启动时间、资源消耗、学习投入）</p><h4 id="1-3-操作系统的构成"><a href="#1-3-操作系统的构成" class="headerlink" title="1.3 操作系统的构成"></a>1.3 操作系统的构成</h4><h5 id="1-3-1-操作系统的核心组件（类似大脑、心脏）（已经发展成熟，变化不大）"><a href="#1-3-1-操作系统的核心组件（类似大脑、心脏）（已经发展成熟，变化不大）" class="headerlink" title="1.3.1 操作系统的核心组件（类似大脑、心脏）（已经发展成熟，变化不大）"></a>1.3.1 操作系统的核心组件（类似大脑、心脏）（已经发展成熟，变化不大）</h5><p> （1）任务创建和管理调度系统<br> （2）内存管理（计算机系统的2大核心资源：CPU算力资源、内存资源）<br> （3）任务间通信机制（沟通、协作）</p><h5 id="1-3-2-操作系统的外围组件（类似四肢）（不同操作系统的差异较大）"><a href="#1-3-2-操作系统的外围组件（类似四肢）（不同操作系统的差异较大）" class="headerlink" title="1.3.2 操作系统的外围组件（类似四肢）（不同操作系统的差异较大）"></a>1.3.2 操作系统的外围组件（类似四肢）（不同操作系统的差异较大）</h5><p> （1）HAL和硬件驱动<br> （2）网络通信和协议栈<br> （3）文件系统<br> （4）GUI系统<br> （5）其他第三方组件</p><h4 id="1-4-总结：操作系统的实质"><a href="#1-4-总结：操作系统的实质" class="headerlink" title="1.4 总结：操作系统的实质"></a>1.4 总结：操作系统的实质</h4><p> （1）操作系统本身是一套软件系统<br> （2）操作系统负责内部管理而非外部业务<br> （3）操作系统的本质是代码复用和功能复用<br> （4）基于操作系统来设计项目是一种思路和技术观<br> （5）操作系统自身的设计是一门学问<br> （6）学习操作系统的直接目的：使用操作系统来做项目做产品<br> （7）学习操作系统源码的目的：更好的使用操作系统，改造甚至自己写新的操作系统</p><h2 id="二、什么是物联网操作系统"><a href="#二、什么是物联网操作系统" class="headerlink" title="二、什么是物联网操作系统"></a>二、什么是物联网操作系统</h2><h4 id="2-1-传统两大类操作系统"><a href="#2-1-传统两大类操作系统" class="headerlink" title="2.1 传统两大类操作系统"></a>2.1 传统两大类操作系统</h4><h5 id="2-1-1-RTOS"><a href="#2-1-1-RTOS" class="headerlink" title="2.1.1 RTOS"></a>2.1.1 RTOS</h5><p> （1）RTOS的定义和特征：实时性强、不复杂、不庞大、任务数不多<br> （2）典型RTOS之ucos、Vxworks、rtlinux<br> （3）RTOS的主要应用场景和技术核心：工业、军工、消费电子等</p><h5 id="2-1-2-桌面、服务器级操作系统"><a href="#2-1-2-桌面、服务器级操作系统" class="headerlink" title="2.1.2 桌面、服务器级操作系统"></a>2.1.2 桌面、服务器级操作系统</h5><p> （1）基于MMU和虚拟地址映射的OS特征<br> （2）典型桌面操作系统Windows<br> （3）典型桌面和服务器级操作系统linux<br> （4）典型智能手机操作系统Android<br> （5）基于虚拟地址的操作系统的优势和技术核心</p><h5 id="2-1-3-两类操作系统的核心差别"><a href="#2-1-3-两类操作系统的核心差别" class="headerlink" title="2.1.3 两类操作系统的核心差别"></a>2.1.3 两类操作系统的核心差别</h5><p> 核心区别：是否支持实时安装应用程序，即：虚拟地址映射才支持。</p><h4 id="2-2-从RTOS到IoTOS"><a href="#2-2-从RTOS到IoTOS" class="headerlink" title="2.2 从RTOS到IoTOS"></a>2.2 从RTOS到IoTOS</h4><h5 id="2-2-1-IoTOS技术上属于RTOS"><a href="#2-2-1-IoTOS技术上属于RTOS" class="headerlink" title="2.2.1 IoTOS技术上属于RTOS"></a>2.2.1 IoTOS技术上属于RTOS</h5><p> （1）IoTOS的硬件平台主要是单片机<br> （2）IoTOS基于实地址而非虚拟地址</p><h5 id="2-2-2-IoTOS的本质特征"><a href="#2-2-2-IoTOS的本质特征" class="headerlink" title="2.2.2 IoTOS的本质特征"></a>2.2.2 IoTOS的本质特征</h5><p> （1）IoTOS面向物联网设备端场景<br> （2）比起实时性参数IoTOS更在意周边生态<br> （3）IoTOS之争核心在于云平台和应用、数据等衍生价值之争，而不是IoTOS本身之争</p><h4 id="2-3-市场主流IoTOS"><a href="#2-3-市场主流IoTOS" class="headerlink" title="2.3 市场主流IoTOS"></a>2.3 市场主流IoTOS</h4><p> （1）华为LiteOS<br> （2）RT-Thread<br> （3）亚马逊freeRTOS<br> （4）TencentOSTiny<br> （5）AliOSThings</p><h4 id="2-4-华为LiteOS竞争优势"><a href="#2-4-华为LiteOS竞争优势" class="headerlink" title="2.4 华为LiteOS竞争优势"></a>2.4 华为LiteOS竞争优势</h4><p> （1）短小精悍历经实战的kernel<br> （2）华为的信心背书与强大支撑资源，华为云IoT技术认证体系<br> （3）丰富的第三方组件支持<br> （4）华为云IoT的对接匹配<br> （5）专业IDE工具IoTStudio支持，类似于STM32的cubemx<br> （6）各种模组厂商和开发生态支持</p><h2 id="三、LiteOS软件架构"><a href="#三、LiteOS软件架构" class="headerlink" title="三、LiteOS软件架构"></a>三、LiteOS软件架构</h2><h4 id="3-1-LiteOS官方资源获取"><a href="#3-1-LiteOS官方资源获取" class="headerlink" title="3.1 LiteOS官方资源获取"></a>3.1 LiteOS官方资源获取</h4><p> （1）官网：<a href="https://www.huawei.com/minisite/liteos/cn/index.html">https://www.huawei.com/minisite/liteos/cn/index.html</a><br> （2）官方文档、 源码获取<br> （4）IoTStudio、 IoT_LINK SDK</p><h4 id="3-2-LiteOS版权说明"><a href="#3-2-LiteOS版权说明" class="headerlink" title="3.2 LiteOS版权说明"></a>3.2 LiteOS版权说明</h4><p> 产品商免费商用。再发布源码要加声明，再发布二进制要在文档中加声明。不能未经允许随意使用著作权人姓名做背书。</p><h4 id="3-3-LiteOS演进历程"><a href="#3-3-LiteOS演进历程" class="headerlink" title="3.3 LiteOS演进历程"></a>3.3 LiteOS演进历程</h4><p> （1）独立IoTOS阶段<br> （2）iot-link SDK全栈式IoTOS阶段1：独立开发的IoTStudio<br> （3）iot-link SDK全栈式IoTOS阶段2：基于vscode插件的IoTStudio</p><h4 id="3-4-LiteOS两种开发方式"><a href="#3-4-LiteOS两种开发方式" class="headerlink" title="3.4 LiteOS两种开发方式"></a>3.4 LiteOS两种开发方式</h4><p> （1）基于Keil等第三方IDE的开发，适合用独立LiteOS，全栈式反而麻烦。<br> （2）基于IoTStudio和IotLink SDK的开发。</p><h4 id="3-5-IoTStudio开发方式"><a href="#3-5-IoTStudio开发方式" class="headerlink" title="3.5 IoTStudio开发方式"></a>3.5 IoTStudio开发方式</h4><p> （1）官方gitbook：<a href="https://flyfishzy.github.io/iotstudio-doc/">https://flyfishzy.github.io/iotstudio-doc/</a><br> （2）安装vscode和iotstudio插件<br> （3）vscode常用技巧请参考其他教程<br> （4）注意：iotstudio是IDE、是容器和工具集，而iotlink是SDK、是源码包。2者是分离合作<br> （5）.vscode目录下是vscode自身的文件和插件，.iotlink目录下是SDK的文件<br> （6）用户创建项目后，项目文件夹里是该项目专有的文件，项目也会外部引用SDK中的文件</p><h4 id="3-6-IoTLink-SDk-框架"><a href="#3-6-IoTLink-SDk-框架" class="headerlink" title="3.6 IoTLink SDk 框架"></a>3.6 IoTLink SDk 框架</h4><h5 id="3-6-1-IoTStudio的图形化管理和编译"><a href="#3-6-1-IoTStudio的图形化管理和编译" class="headerlink" title="3.6.1 IoTStudio的图形化管理和编译"></a>3.6.1 IoTStudio的图形化管理和编译</h5><h5 id="3-6-2-SDK的组成部分"><a href="#3-6-2-SDK的组成部分" class="headerlink" title="3.6.2 SDK的组成部分"></a>3.6.2 SDK的组成部分</h5><h4 id="3-7-IoTLink-SDK-主体"><a href="#3-7-IoTLink-SDK-主体" class="headerlink" title="3.7 IoTLink SDK 主体"></a>3.7 IoTLink SDK 主体</h4><h4 id="3-8-IoTStudio使用"><a href="#3-8-IoTStudio使用" class="headerlink" title="3.8 IoTStudio使用"></a>3.8 IoTStudio使用</h4><h5 id="3-8-1-基本使用"><a href="#3-8-1-基本使用" class="headerlink" title="3.8.1 基本使用"></a>3.8.1 基本使用</h5><h5 id="3-8-2-工程SDK配置原理"><a href="#3-8-2-工程SDK配置原理" class="headerlink" title="3.8.2 工程SDK配置原理"></a>3.8.2 工程SDK配置原理</h5>]]></content>
      
      
      <categories>
          
          <category> HUAWEI LiteOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOT:物联网简介</title>
      <link href="/2021/02/01/internet-of-things/"/>
      <url>/2021/02/01/internet-of-things/</url>
      
        <content type="html"><![CDATA[<h1 id="Internet-of-things：物联网简介"><a href="#Internet-of-things：物联网简介" class="headerlink" title="Internet of things：物联网简介"></a>Internet of things：物联网简介</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><h4 id="1-1-百科中的定义"><a href="#1-1-百科中的定义" class="headerlink" title="1.1 百科中的定义"></a>1.1 百科中的定义</h4><p>  物联网（The Internet of Things，简称IOT）是指通过 各种信息传感器、射频识别技术、全球定位系统、红外感应器、激光扫描器等各种装置与技术，实时采集任何需要监控、 连接、互动的物体或过程，采集其声、光、热、电、力学、化 学、生物、位置等各种需要的信息，通过各类可能的网络接入，实现物与物、物与人的泛在连接，实现对物品和过程的智能化感知、识别和管理。</p><h4 id="1-2-对物联网的总结"><a href="#1-2-对物联网的总结" class="headerlink" title="1.2 对物联网的总结"></a>1.2 对物联网的总结</h4><p> 单靠这样官方的定义，我们很难认识到物联网的本质。根据本人这么久的学习，对物联网做如下总结：<br>  1.物联网是互联网的延申<br>  2.物联网注重“人与物”，“物与物”<br>  3.连接是物联网的基础，基于连接的业务才是物联网的价值<br>  4.融合性学科，而非单一</p><h2 id="2-发展历程"><a href="#2-发展历程" class="headerlink" title="2.发展历程"></a>2.发展历程</h2><h4 id="2-1-时间轴"><a href="#2-1-时间轴" class="headerlink" title="2.1 时间轴"></a>2.1 时间轴</h4><p> 1.1990年可乐贩售机<br> 2.1991年MIT提出物联网概念，主要是RFID技术<br> 3.2005年ITU重新定义物联网，不只是RFID技术<br> 4.2009年，建立无锡物联网研究所<br> 5.2015年，《中国制造2025》强国战略</p><h4 id="2-2-总结"><a href="#2-2-总结" class="headerlink" title="2.2 总结"></a>2.2 总结</h4><p> 物联网在当今社会阶段正在高速发展，中国有阿里，腾讯，百度这样的企业投入，并且有雄厚的电子产业基础。物联网发展很有优势。</p><h2 id="3-典型案例"><a href="#3-典型案例" class="headerlink" title="3.典型案例"></a>3.典型案例</h2><h4 id="3-1-共享单车"><a href="#3-1-共享单车" class="headerlink" title="3.1 共享单车"></a>3.1 共享单车</h4><p> 实际上解决了随时随地低成本的有偿租借问题，工作原理：本地有MCU，可以和手机通信，也可以和云端服务器进行通信，通过GPRS（2.5G）。核心是智能锁的设计。</p><h4 id="3-2-断电检测报警器"><a href="#3-2-断电检测报警器" class="headerlink" title="3.2 断电检测报警器"></a>3.2 断电检测报警器</h4><p> 解决了低成本故障判断问题。要求低功耗。主要特点为单向上报。大多数用电池供电。</p><h4 id="3-3-智慧城市共享停车系统"><a href="#3-3-智慧城市共享停车系统" class="headerlink" title="3.3 智慧城市共享停车系统"></a>3.3 智慧城市共享停车系统</h4><p> 解决了城市车位利用率低的问题。使用传感器和出入识别系统，动态管理车位的收费。</p><h4 id="3-4-案例总结"><a href="#3-4-案例总结" class="headerlink" title="3.4 案例总结"></a>3.4 案例总结</h4><p> 以上只是物联网应用的冰山一角，未来物联网可以渗透至人类生活的各个方面。物联网的应用很具体，实际的开发必须由确定的场景作为前提条件。</p><h2 id="4-分支应用领域"><a href="#4-分支应用领域" class="headerlink" title="4.分支应用领域"></a>4.分支应用领域</h2><h4 id="4-1-分支应用及其总结"><a href="#4-1-分支应用及其总结" class="headerlink" title="4.1 分支应用及其总结"></a>4.1 分支应用及其总结</h4><p> 分支应用：物联网的应用主要包括智慧城市（智慧交通、安防、建筑），智能家居（智慧酒店、商场、办公、家庭），智慧医疗（输液监控、监测报警手环），智慧物流，智慧农业，智能制造，智慧零售（快递柜、无人零售终端，配送机器人）。<br> 总结：物联网的核心是基于连接的应用，连接是通道，应用是目的。物联网具有“+”的属性，可以结合其他行业。是未来重要的技术变革。</p><h2 id="5-技术实现架构"><a href="#5-技术实现架构" class="headerlink" title="5.技术实现架构"></a>5.技术实现架构</h2><h4 id="5-1-“云管端”模型"><a href="#5-1-“云管端”模型" class="headerlink" title="5.1 “云管端”模型"></a>5.1 “云管端”模型</h4><p> 早期简单化，本地化，离散化。现代标准架构：云——管——端。<br> 云：物联网云平台，负责设备的接入和管理，应用部署。<br> 管：通信管道，抽象概念，对应各种有线无线通信技术。<br> 端：终端，物联网设备端，嵌入到“物”中的东西。包括MCU、电源、传感器。</p><h4 id="5-2-四层架构"><a href="#5-2-四层架构" class="headerlink" title="5.2 四层架构"></a>5.2 四层架构</h4><p> 应用层、平台层、网络层、感知层</p><h2 id="6-各层次涉及的核心技术"><a href="#6-各层次涉及的核心技术" class="headerlink" title="6.各层次涉及的核心技术"></a>6.各层次涉及的核心技术</h2><h4 id="6-1-传感层"><a href="#6-1-传感层" class="headerlink" title="6.1 传感层"></a>6.1 传感层</h4><h5 id="物联网设备端，如温度监控器、摄像头、车载智能终端、智慧屏（电视机）等"><a href="#物联网设备端，如温度监控器、摄像头、车载智能终端、智慧屏（电视机）等" class="headerlink" title="物联网设备端，如温度监控器、摄像头、车载智能终端、智慧屏（电视机）等"></a>物联网设备端，如温度监控器、摄像头、车载智能终端、智慧屏（电视机）等</h5><p> 核心技术：MCU及其编程技术、传感器、电池及低功耗技术、通信模组（蓝牙、wifi、2345G、LoRa等）、物联网操作系统及其生态（如模组对接、协议栈等）</p><h4 id="6-2-网络层"><a href="#6-2-网络层" class="headerlink" title="6.2 网络层"></a>6.2 网络层</h4><h5 id="为物联网系统提供通信管道的基础设施和软硬件、运维服务等的综合体。"><a href="#为物联网系统提供通信管道的基础设施和软硬件、运维服务等的综合体。" class="headerlink" title="为物联网系统提供通信管道的基础设施和软硬件、运维服务等的综合体。"></a>为物联网系统提供通信管道的基础设施和软硬件、运维服务等的综合体。</h5><p> 由多段构成而不是单一体。<br> 有多种实现架构，如蜂窝网络、网关式网络、组网式网络等。<br> 关注参数：通信距离、稳定性、延迟、带宽和速度、建设成本和运维成本等。<br> 一部分是现有成熟技术，一部分是专为IoT设计和建设。</p><h4 id="6-3-平台层"><a href="#6-3-平台层" class="headerlink" title="6.3 平台层"></a>6.3 平台层</h4><h5 id="物联网云平台，典型如华为云IoT、阿里云IoT、腾讯云IoT等，是专用于物联网的云平台。"><a href="#物联网云平台，典型如华为云IoT、阿里云IoT、腾讯云IoT等，是专用于物联网的云平台。" class="headerlink" title="物联网云平台，典型如华为云IoT、阿里云IoT、腾讯云IoT等，是专用于物联网的云平台。"></a>物联网云平台，典型如华为云IoT、阿里云IoT、腾讯云IoT等，是专用于物联网的云平台。</h5><p> 提供设备接入、管理、安全、数据、AI能力等普遍性的物联网常用功能。<br> 提供应用开发和部署能力，可直接承载用户应用。<br> 提供对接能力，可对接外部应用，也可对接第三方服务能力。</p><h4 id="6-4-应用层"><a href="#6-4-应用层" class="headerlink" title="6.4 应用层"></a>6.4 应用层</h4><h5 id="应用就是直接面向客户需求，解决客户问题，向客户提供服务的东西的打包。"><a href="#应用就是直接面向客户需求，解决客户问题，向客户提供服务的东西的打包。" class="headerlink" title="应用就是直接面向客户需求，解决客户问题，向客户提供服务的东西的打包。"></a>应用就是直接面向客户需求，解决客户问题，向客户提供服务的东西的打包。</h5><p> 应用一般包括：服务端后台、前端前台、手机客户端、专用设备客户端等。<br> 不同行业不同应用差异很大，同行业不同客户也会有不同需求。<br> 应用是物联网的直接价值产生地，是物联网项目的总纲领。</p><h2 id="7-华为的物联网解决方案"><a href="#7-华为的物联网解决方案" class="headerlink" title="7.华为的物联网解决方案"></a>7.华为的物联网解决方案</h2><h4 id="7-1-华为云IoT"><a href="#7-1-华为云IoT" class="headerlink" title="7.1 华为云IoT"></a>7.1 华为云IoT</h4><p> 华为云官网：<a href="https://www.huaweicloud.com/">https://www.huaweicloud.com</a><br> 华为云IoT主页：<a href="https://www.huaweicloud.com/product/IoTCollect.html">https://www.huaweicloud.com/product/IoTCollect.html</a><br> 当前4大块：IoT联接服务、IoT数据分析服务、IoT行业使能服务、IoT安全服务</p><h4 id="7-2-华为物联网操作系统LiteOS"><a href="#7-2-华为物联网操作系统LiteOS" class="headerlink" title="7.2 华为物联网操作系统LiteOS"></a>7.2 华为物联网操作系统LiteOS</h4><p> 华为云官网LiteOS入口：<a href="https://www.huaweicloud.com/product/liteos.html">https://www.huaweicloud.com/product/liteos.html</a><br> LiteOS官网：<a href="https://www.huawei.com/minisite/liteos/cn/index.html">https://www.huawei.com/minisite/liteos/cn/index.html</a><br> LiteOS论坛：<a href="https://bbs.huaweicloud.com/forum/forum-729-1.html">https://bbs.huaweicloud.com/forum/forum-729-1.html</a></p><h4 id="7-3-IoT-Studio及IoT-LINK-SDK"><a href="#7-3-IoT-Studio及IoT-LINK-SDK" class="headerlink" title="7.3 IoT Studio及IoT_LINK SDK"></a>7.3 IoT Studio及IoT_LINK SDK</h4><h5 id="注1：IoT-Studio是华为开发的集成开发环境，IoT-LINK-SDK是LiteOS为了适应物联网的需求，而对LiteOS进行的扩充。"><a href="#注1：IoT-Studio是华为开发的集成开发环境，IoT-LINK-SDK是LiteOS为了适应物联网的需求，而对LiteOS进行的扩充。" class="headerlink" title="注1：IoT Studio是华为开发的集成开发环境，IoT_LINK SDK是LiteOS为了适应物联网的需求，而对LiteOS进行的扩充。"></a>注1：IoT Studio是华为开发的集成开发环境，IoT_LINK SDK是LiteOS为了适应物联网的需求，而对LiteOS进行的扩充。</h5><h5 id="注2：SDK-软件开发工具包"><a href="#注2：SDK-软件开发工具包" class="headerlink" title="注2：SDK 软件开发工具包"></a>注2：SDK 软件开发工具包</h5><p> IoT Studio是华为专为IoT开发工程师设计的一站式IoT开发IDE<br> IoT_LINK SDK是LiteOS的全栈式组织，可配合IoT Studio工作，是演进方向。<br> 未来的发展方向：图形化、组件化、松耦合、全栈式<br> IoT Studio当前下载入口：<a href="https://developer.huaweicloud.com/resource/iot.html">https://developer.huaweicloud.com/resource/iot.html</a></p><h4 id="7-4-华为物联网认证"><a href="#7-4-华为物联网认证" class="headerlink" title="7.4 华为物联网认证"></a>7.4 华为物联网认证</h4><p> 华为认证：华为提供了一整套物联网解决方案，可以考取三个等级的证书。<br> 官网：官网：<a href="https://e.huawei.com/cn/talent/#/admin/certifi">https://e.huawei.com/cn/talent/#/admin/certifi</a><br> 华为认证IoT类目</p><h4 id="7-5-NBIOT芯片"><a href="#7-5-NBIOT芯片" class="headerlink" title="7.5 NBIOT芯片"></a>7.5 NBIOT芯片</h4><p> （1）什么是NBIOT，窄带物联网，本质是一种通信技术，类似于2G、3G、4G<br>（2）NBIOT和5G的关系：NBIOT属于5G mMTC应用的事实标准，是5G大连接业务的一种实现。<br>（3）NBIOT特点：超低功耗、超大连接、超低成本、超强覆盖<br>（4）NBIOT应用：传感器类如烟感探头、路边停车、三表等，控制类如智慧路灯<br>（5）NBIOT现状：2018年开始发展，目前中国三大运营商均已建网，产品落地发展中。<br>（6）2G会逐步退网，部分被NBIOT替代，部分被4G替代。<br>（7）华为直接提供：NBIOT芯片</p>]]></content>
      
      
      <categories>
          
          <category> HUAWEI LiteOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduce </tag>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式OS:UCOSIII</title>
      <link href="/2021/01/28/uc-osiii/"/>
      <url>/2021/01/28/uc-osiii/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式实时操作系统UCOSIII"><a href="#嵌入式实时操作系统UCOSIII" class="headerlink" title="嵌入式实时操作系统UCOSＩＩＩ"></a>嵌入式实时操作系统UCOSＩＩＩ</h1><h2 id="UCOSIII简介"><a href="#UCOSIII简介" class="headerlink" title="UCOSIII简介"></a>UCOSIII简介</h2><p> 操作系统分为很多类：大型操作系统（如Windows10、DOS、MAC），移动端操作系统（Android），实时操作系统（freeRTOS、UCOSII），物联网操作系统（LiteOS） 等等。</p><p> 本文所介绍的UCOSIII属于实时操作系统，主要应用于嵌入式领域（嵌入式应用对时间的精确度要求较高）。其主要特点为可移植、可固化的、可裁剪的、占先式多任务实时内核，它适用于多种微处理器，微控制器和数字处理芯片。</p><h2 id="前后台系统"><a href="#前后台系统" class="headerlink" title="前后台系统"></a>前后台系统</h2><p> 前后台系统（普通前后台系统的实时性特别差，后台任务必须按照顺序执行）</p><p> 后台：前后台系统类似与大小循环嵌套，大循环按照UCOSIII的代码顺序自上而下运行，而小循环也只能按照顺序来执行。</p><p> 前台：前台主要由各种中断组成，包括外部中断、定时器中断、串口中断、以及ISR。</p><p> 前后台系统的灵活性较差。任务的执行循序不能实时改变，不能适应实时的应用场景。</p><h2 id="可剥夺型内核"><a href="#可剥夺型内核" class="headerlink" title="可剥夺型内核"></a>可剥夺型内核</h2><p> 可以剥夺其他任务的使用权，总是运行就绪任务中优先级最高的任务。</p><p> 操作系统根据任务的优先级选择接下来要执行的任务，延迟在us到ms级别。</p><h2 id="实时操作系统的任务优先级分类"><a href="#实时操作系统的任务优先级分类" class="headerlink" title="实时操作系统的任务优先级分类"></a>实时操作系统的任务优先级分类</h2><p> RTOS任务优先级分类（每个等级的任务无限循环运行）</p><p> UCOSIII的任务数没有限制，UCOSII最多运行255个任务。可裁剪，可剥夺型内核。包括了实时操作系统的所有功能：资源管理，同步，任务通信。</p><h2 id="资料网站"><a href="#资料网站" class="headerlink" title="资料网站"></a>资料网站</h2><p> Micrium官网：<a href="http://www.micrium.com/">www.micrium.com</a></p><p> 开源电子网：<a href="http://www.opened.com/">www.opened.com</a></p>]]></content>
      
      
      <categories>
          
          <category> UCOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Introduce </tag>
            
            <tag> Operating System </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo常用命令</title>
      <link href="/2021/01/13/hello-world/"/>
      <url>/2021/01/13/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h1><pre><code>hexo n "文章名" == hexo new "文章名"</code></pre><h1 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h1><pre><code>hexo g == hexo generate     #生成hexo s == hexo server         #启动服务预览</code></pre><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>hexo clean                #清除缓存 网页正常情况下可以忽略此条命令hexo g == hexo generate   #生成静态网页hexo d == hexo deploy          #开始部署hexo g -d                       #命令合并</code></pre><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><pre><code>hexo server -p 5000     #更改端口，默认端口4000hexo server -i 192.168.1.1 #自定义 IPhexo help  # 查看帮助hexo version    #查看Hexo的版本</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Practice </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018秋学期总结</title>
      <link href="/2019/04/21/weeklysummary/"/>
      <url>/2019/04/21/weeklysummary/</url>
      
        <content type="html"><![CDATA[<h4 id="大二上学期："><a href="#大二上学期：" class="headerlink" title="大二上学期："></a>大二上学期：</h4><h5 id="2018秋学期总结："><a href="#2018秋学期总结：" class="headerlink" title="2018秋学期总结："></a>2018秋学期总结：</h5><pre><code>大二上眨眼间就过去了这个学期在很多方面都有改变，先简要记录一下这学期的重大事件吧。</code></pre><p>从开学前的暑假开始就在学stm32，在开学前的几天用它突击做好了一个答辩作品，是一个可以通过距离及温度来控制亮度的LED。假期制作时，觉得代码难度挺高的，可能是现在能力代码能力有所提升，回想起来觉得作品优点简陋。但是没关系，后期我会不断完善这个作品：加上人体感应、LCD触摸屏等等。参加以后学校的单片机设计竞赛。</p><p>经过自己的努力，在开学工作室换届时，如愿当选了代理组长，熟悉各种之前不了解的流程，还有招新：笔试、面试、考核、每周测试。那几周心思就都在工作室上面，没有太多时间在工作室静下心来学习。 虽然累但是感觉能为工作室做一些事情内心很充实。 </p><p>之后有一次例会，偶然之中听到了学长说光看视频是学不会32的。我自己也觉得学<br>32有些不扎实，就看野火的《stm32库开发指南》这本书。看了几周之后，常用的部分都看完了，就在慢慢了解32上运行的操作系统RTOS。也是看视频。看完了ucosII统的一些背景以及uc-lib和uc-cpu的部分源代码分析。纸上得来终觉浅，要是学了不用，怎么也会忘记的。接下来就是国庆期间，帮一个叫环保侠的创业团队做了一个智能垃圾桶的原型。十一月份的组间答辩完善了自己的暑期答辩作品上去答辩。到了单片机大赛提交作品的时候，又是这个作品，多加了一个触摸屏，用户可以在操作界面上用手指点击进行操作，得了一个三等奖。</p><p>不知道在哪一周买了一个旋转LED，就是那种打开开关之后，硬件旋转起来，给人们呈现出一幅3D动画效果。这个东西的原理是：人眼会产生一个视觉暂留，硬件通过旋转起来显示不同的图像，来达到这种效果。回想起来这学期做的杂事也不少，学过C++,想在跟着课程重新学习一遍数据结构，但只有三分种热度…学了几天就停了下来，总想着后面还有时间。</p><p>之前也总是分不清uboot和ubuntu，直到一天自己在电脑上安装了虚拟机，装了ubuntu，学完了一些命令之后才对ubuntu有了一定的了解，知道它的价值在哪里。后来也了解了uboot的基本作用是什么。Uboot是启动Linux操作系统内核的一段程序，在启动时对机器的各部分iNand、Nandflash等进行部署。</p><p>这学期也确定了自己的目标，在上学期因为对嵌入式感兴趣买了嵌入式初级工程师的课程之后，这学期也一直在学习。在这期间因为种种原因动摇过自己学习嵌入式的想法：学长学了很久的嵌入式，最终找到了一份无关的工作。还有网上的一些分析等等。我自己也想过学点其他的，要不要搞软件，搞前端。在经过长时间的深思熟虑之后，我还是决定坚持下去，毕竟就算毕业找不到一份对胃口的工作，但是谁能保证毕业几年之后呢。而且，在学习的过程中，自己的编程功底也会不知不觉地提升。</p><p>最后，再总结一些纯理论的知识点：这学期基本上看完了C高级部分。知道了之前根本不了解的一些细节，对内存以及存储的理解更加深入，知道了一些高级宏offsetof和container_of内部的工作原理、了解了通信系统中的大小端以及如何用c语言写代码进行测试。学习了静态链接库和动态链接库的制作和使用。一边看视频也在做笔记，现在笔记还没有做完，大概只做了1/2，之后会在总结笔记的过程中再去学习一遍。C语言是个工具，同时又有很深的学问。之后我会在学习ARM裸机时，在应用中提升c语言。裸机之后再是uboot，linux移植……</p><p>在临近期末的这段时间，在准备全国大学生工程训练大赛，考试之后也要在学校继续准备一段时间。主要就是编写代码。希望在回家之前能够完成的差不多，回家之后压力就小一点了，可以安心过个好年。这个比赛和之前报名的蓝桥杯时间也有些冲突。总之两个都努力准备，300报名费可不能白交~</p><p>希望在工作室的大家也都加油。不断朝好的方向发展。莫教冰鉴负初心！</p><h4 id="大二下学期："><a href="#大二下学期：" class="headerlink" title="大二下学期："></a>大二下学期：</h4><h5 id="寒假总结："><a href="#寒假总结：" class="headerlink" title="寒假总结："></a>寒假总结：</h5><p>一个多月的寒假转瞬即逝，这个假期过得非常充实。上学期放假之后在学校准备比赛，天气寒冷加上休息不规律，成功让自己病倒了。喉咙很疼，每天只能吃包子喝粥，医生说是扁桃体发炎。接下来一段时间每天的生活就是：上午打吊瓶+下午在工训楼准备比赛。最幸运的事就是有一群志同道合的的队友，每天忙完一边吹牛一边回寝室。就这样到了小年之后，在老师的指导下作品有了一个雏形，至少可以动起来。这给我们打了一剂定心丸，三月比赛的紧张感也随之缓解。学校留校的同学已经寥寥无几。我和队友这个时候一起拼车回家。</p><p>我一直希望自己过得充实一点，奈何力不从心，回到家就彻底放松了。开始的时候有太多宏伟的计划：多学一门语言；除了准备比赛之外；看《深入理解计算机系统》；再学习一下ARM的开发板；做一个和比赛作品不一样的寒假答辩作品。到头来只准备了一个工程训练大赛。虽然觉得寒假在家没有投入学习太多时间，但是并不觉得后悔，毕竟只有假期才可以多陪陪家人，感受来自家庭的温暖。寒假偷的懒，开学之后自己补回来。这学期也大致有了一个计划。</p><p>最重要的一件事就是思想有点转变。没有之前那么执着于本科完了马上就业。更想尽可能凭自己的努力，再在校园里发展一段时间。除了比赛，上周还被学长介绍去电气学院做项目，虽然有人评价项目并不难，但是好好做就肯定会有收获。<br>第二周计划：<br>１.还是很期待招新的，好好准备；<br>２.继续在老师的指导下准备比赛；<br>３.开始准备六级，提前背单词总没有坏处；<br>４.早上早起去跑步。</p>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
